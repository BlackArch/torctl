#!/bin/bash

################################################################################
#                                                                              #
# torctl.sh - redirect all traffic through tor network                         #
#                                                                              #
# DESCRIPTION                                                                  #
# Script to redirect all traffic through tor network including                 #
# dns queries for anonymizing entire system                                    #
#                                                                              #
#                                                                              #
# AUTHORS                                                                      #
# sepehrdad.dev@gmail.com                                                      #
#                                                                              #
################################################################################

# torctl.sh version
VERSION="torctl.sh v0.5.3"

# exclude locals
TOR_EXCLUDE="192.168.0.0/16 172.16.0.0/12 10.0.0.0/8"

# tor uid
TOR_UID="tor"

# tor socks port
TOR_PORT="9040"

# tor dns port
TOR_DNS="9053"

# colors
GREEN=""
RED=""
REDB=""
YELLOW=""
BLUE=""
RESET=""

if [ -t 1 ];then
    if tput setaf 0 &>/dev/null; then
        RESET="$(tput sgr0)"
        BOLD="$(tput bold)"
        GREEN="$(tput setaf 2)"
        RED="$(tput setaf 1)"
        REDB="${BOLD}${RED}"
        YELLOW="$(tput setaf 3)"
        BLUE="$(tput setaf 4)"
    else
        RESET="\e[0m"
        BOLD="\e[1m"
        GREEN="\e[32m"
        RED="\e[31m"
        REDB="${BOLD}${RED}"
        YELLOW="\e[33m"
        BLUE="\e[34m"
    fi
fi

# backup dir
BACKUPDIR="/tmp/torctl"

# print error and exit
err()
{
    echo "${RED}[-]${RESET} ERROR: ${@}"
    exit 1
}


# print warning
warn()
{
    echo "${YELLOW}[!]${RESET} WARNING: ${@}"
}

# print message
msg()
{
    echo "${GREEN}[+]${RESET} ${@}"
}

# print info
info()
{
    echo "${BLUE}[*]${RESET} ${@}"
}

banner()
{
    echo -e "${REDB}--==[ torctl.sh by blackarch.org ]==--${RESET}\n"
}

version()
{
    echo "${VERSION}"
}

checkroot()
{
    if [ $(id -u) -ne 0 ]; then
        err "This script must be run as root"
    fi
}

startservice()
{
    SERVICE=${@}
    if [[ $(systemctl is-active $SERVICE) != "active" ]]; then
        warn "$SERVICE is not started"
        info "starting $SERVICE service"
        systemctl start $SERVICE || err "unable to start $SERVICE service"
        msg "started $SERVICE service"
    else
        warn "$SERVICE is running"
        info "reloading $SERVICE service"
        systemctl reload $SERVICE || err "unable to reload $SERVICE service"
        msg "reloaded $SERVICE service"
    fi

}

stopservice()
{
    SERVICE=${@}
    if [[ $(systemctl is-active $SERVICE) == "active" ]]; then
        warn "$SERVICE is active"
        info "stopping $SERVICE service"
        systemctl stop $SERVICE || err "unable to stop $SERVICE service"
        msg "stopped $SERVICE service"
    fi
}

ip()
{
    RADDR=$(wget -qO- http://ipecho.net/plain)
    msg "remote ip: $RADDR"
}

is-started()
{
    if [ -e $BACKUPDIR/started ];then
        return 0
    fi
    return 1
}

start()
{
    # check if root
    checkroot

    # check if started
    if is-started; then
        err "torctl is already started"
    fi

    # generate new torrc
    gentorrc

    # start needed services
    startservice iptables
    startservice tor

    info "backing up nameservers"
    mv /etc/resolv.conf $BACKUPDIR/resolv.conf.bak
    echo -e '# generated by torctl\nnameserver 127.0.0.1\nnameserver 1.1.1.1\nnameserver 1.0.0.1' > /etc/resolv.conf;
    msg "backed up nameservers"

    info "backing up iptables rules"
    iptables-save > $BACKUPDIR/iptables.rules.bak
    msg "backed up iptables rules"

    iptables -F
    iptables -t nat -F

    # disable ipv6
    info "disabling ipv6"
    sysctl -w net.ipv6.conf.all.disable_ipv6=1 > "/dev/null"
    sysctl -w net.ipv6.conf.default.disable_ipv6=1 > "/dev/null"
    msg "disabled ipv6"

    info "redirecting all traffic through tor"
    # set iptables nat
    iptables -t nat -A OUTPUT -m owner --uid-owner $TOR_UID -j RETURN
    # set dns redirect
    iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports $TOR_DNS
    iptables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports $TOR_DNS
    iptables -t nat -A OUTPUT -p udp -m owner --uid-owner $TOR_UID -m udp --dport 53 -j REDIRECT --to-ports $TOR_DNS

    # resolve .onion domains mapping 10.192.0.0/10 address space
    iptables -t nat -A OUTPUT -p tcp -d 10.192.0.0/10 -j REDIRECT --to-ports $TOR_PORT
    iptables -t nat -A OUTPUT -p udp -d 10.192.0.0/10 -j REDIRECT --to-ports $TOR_PORT
    # exclude locals
    for NET in $TOR_EXCLUDE 127.0.0.0/9 127.128.0.0/10; do
        iptables -t nat -A OUTPUT -d $NET -j RETURN
        iptables -A OUTPUT -d "$NET" -j ACCEPT
    done

    # redirect all other output through tor
    iptables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports $TOR_PORT
    iptables -t nat -A OUTPUT -p udp -j REDIRECT --to-ports $TOR_PORT
    iptables -t nat -A OUTPUT -p icmp -j REDIRECT --to-ports $TOR_PORT

    # accept already established connections
    iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

    # allow only tor output
    iptables -A OUTPUT -m owner --uid-owner $TOR_UID -j ACCEPT
    iptables -A OUTPUT -j REJECT
    msg "all traffic is being redirected through tor"

    touch $BACKUPDIR/started
}


stop()
{
    # check if root
    checkroot

    # check if stopped
    if ! is-started; then
        err "torctl is already stopped"
    fi

    iptables -F
    iptables -t nat -F
    if [ -f $BACKUPDIR/iptables.rules.bak ]; then
        warn "restoring iptables rules"
        iptables-restore < $BACKUPDIR/iptables.rules.bak
        rm -f $BACKUPDIR/iptables.rules.bak
        msg "restored iptables rules"
    fi

    if [ -e $BACKUPDIR/resolv.conf.bak ]; then
        warn "restoring nameservers"
        rm -f $BACKUPDIR/resolv.conf
        mv $BACKUPDIR/resolv.conf.bak /etc/resolv.conf
        msg "restored nameservers"
    fi

    if [ -e $BACKUPDIR/torrc.bak ]; then
        warn "restoring tor config"
        rm -f /etc/tor/torrc
        mv $BACKUPDIR/torrc.bak /etc/tor/torrc
        msg "restored tor config"
    fi

    # enable ipv6
    info "enabling ipv6"
    sysctl -w net.ipv6.conf.all.disable_ipv6=0 > "/dev/null"
    sysctl -w net.ipv6.conf.default.disable_ipv6=0 > "/dev/null"
    stopservice tor

    rm -f $BACKUPDIR/started
}


chngid()
{
    # check if root
    checkroot

    # check if stopped
    if ! is-started; then
        err "torctl is stopped"
    fi

    info "changing tor identity"
    stopservice tor > "/dev/null"
    sleep 1
    startservice tor > "/dev/null"
    msg "tor identity changed"
}


status()
{
    checkroot
    TORSTATUS=$(systemctl is-active tor)
    MEMWIPESTATUS=$(systemctl is-enabled torctl-memwipe)
    AUTOSTARTSTATUS=$(systemctl is-enabled torctl-autostart)
    if [[ "${TORSTATUS}" == "active" ]];then
        msg "tor service is: ${TORSTATUS}"
    else
        warn "tor service is: ${TORSTATUS}"
    fi
    if [[ "${MEMWIPESTATUS}" == "enabled" ]];then
        msg "torctl-memwipe service is: ${MEMWIPESTATUS}"
    else
        warn "torctl-memwipe service is: ${MEMWIPESTATUS}"
    fi
    if [[ "${AUTOSTARTSTATUS}" == "enabled" ]];then
        msg "torctl-autostart service is: ${AUTOSTARTSTATUS}"
    else
        warn "torctl-autostart service is: ${AUTOSTARTSTATUS}"
    fi
}

gentorrc()
{
    checkroot
    TORRC="/etc/tor/torrc"
    warn "backing up tor config"
    mv "$TORRC" $BACKUPDIR/torrc.bak
    cat > "${TORRC}" << EOF
# generated by torctl
DataDirectory /var/lib/tor
VirtualAddrNetwork 10.192.0.0/10
AutomapHostsOnResolve 1
AutomapHostsSuffixes .exit,.onion
TransPort 127.0.0.1:$TOR_PORT IsolateClientAddr IsolateSOCKSAuth IsolateClientProtocol IsolateDestPort IsolateDestAddr
SocksPort 127.0.0.1:9050 IsolateClientAddr IsolateSOCKSAuth IsolateClientProtocol IsolateDestPort IsolateDestAddr
ControlPort 9051
HashedControlPassword 16:FDE8ED505C45C8BA602385E2CA5B3250ED00AC0920FEC1230813A1F86F
DNSPort 127.0.0.1:$TOR_DNS
HardwareAccel 1
TestSocks 1
AllowNonRFC953Hostnames 0
WarnPlaintextPorts 23,109,110,143,80
ClientRejectInternalAddresses 1
NewCircuitPeriod 40
MaxCircuitDirtiness 600
MaxClientCircuitsPending 48
UseEntryGuards 1
EnforceDistinctSubnets 1
EOF
    chmod 644 ${TORRC}
    msg "backed up tor config"
}

autowipe()
{
    checkroot
    warn "enabling torctl-memwipe"
    systemctl enable torctl-memwipe > "/dev/null"
    msg "enabled torctl-memwipe"
}

wipe()
{
    checkroot
    echo 1024 > /proc/sys/vm/min_free_kbytes
    echo 3  > /proc/sys/vm/drop_caches
    echo 1  > /proc/sys/vm/oom_kill_allocating_task
    echo 1  > /proc/sys/vm/overcommit_memory
    echo 0 > /proc/sys/vm/oom_dump_tasks
    smem-secure-delete -fllv
}

autostart()
{
    checkroot
    warn "enabling torctl-autostart"
    systemctl enable torctl-autostart > "/dev/null"
    msg "enabled torctl-autostart"
}

checkbackupdir()
{
    if [ ! -d $BACKUPDIR ]; then
        mkdir -p $BACKUPDIR
    fi
}

usage()
{
    echo -e "Usage: torctl.sh COMMAND\n"
    echo -e "A script to redirect all traffic through tor network\n"
    echo -e "Commands:"
    echo -e "  start      - start tor and redirect all traffic through tor"
    echo -e "  stop       - stop tor and redirect all traffic through clearnet"
    echo -e "  status     - get tor service status"
    echo -e "  restart    - restart tor and traffic rules"
    echo -e "  autowipe   - enable memory wipe at shutdown"
    echo -e "  autostart  - start torctl at startup"
    echo -e "  ip         - get remote ip address"
    echo -e "  chngid     - change tor identity"
    echo -e "  version    - print version of torctl and exit\n"
}

main()
{
    banner
    checkbackupdir
    case "$1" in
        start)
            start
        ;;
        stop)
            stop
        ;;
        status)
            status
        ;;
        restart)
            stop
            sleep 1
            start
        ;;
        autowipe)
            autowipe
        ;;
        autostart)
            autostart
        ;;
        ip)
            ip
        ;;
        chngid)
            chngid
        ;;
        version)
            version
        ;;
        wipe)
            wipe
        ;;
        *)
            usage
            exit 1
        ;;
    esac
    exit 0
}

# call main
main "${@}"


# EOF
